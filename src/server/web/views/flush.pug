doctype html

html
	#msg
	script.
		const msg = document.getElementById('msg');

		const promises = [];

		try {
			localStorage.clear();
			message('localStorage cleared');

			promises.push(new Promise((res, rej) => {
				const delDB = indexedDB.deleteDatabase('MisskeyClient');

				const to = setTimeout(() => {
					message('indexedDB MisskeyClient clearing timeout.');
					rej();
				}, 10000)

				delDB.onsuccess = () => {
					message('indexedDB MisskeyClient cleared.');
					clearTimeout(to);
					res();
				};
				delDB.onerror = () => {
					message(`indexedDB MisskeyClient clearing failed.`);
					clearTimeout(to);
					rej();
				};
			}));

			promises.push(new Promise((res, rej) => {
				const delDB = indexedDB.deleteDatabase('vuex');

				const to = setTimeout(() => {
					message('indexedDB vuex clearing timeout.');
					rej();
				}, 10000)

				delDB.onsuccess = () => {
					message('indexedDB vuex cleared.');
					clearTimeout(to);
					res();
				};
				delDB.onerror = () => {
					message(`indexedDB vuex clearing failed.`);
					clearTimeout(to);
					rej();
				};
			}));

			if (navigator.serviceWorker && navigator.serviceWorker.controller) {
				navigator.serviceWorker.controller.postMessage('clear');
				promises.push(navigator.serviceWorker.getRegistrations()
					.then(registrations => {
						return Promise.all(registrations.map(registration => registration.unregister()));
					})
					.then(() => {
						message('ServiceWorker unregistered.');
					}));
			}

			Promise.all(promises).then(() => {
				message('Success Flush! Please reopen Misskey.\n成功しました。Misskeyを開き直してください。');
			}, e => {
				message(`${e}¥n¥nFlush Failed. Please reopen Misskey.\n失敗しました。Misskeyを開き直してください。`);
			})
		} catch (e) {
			console.error(e);
			message(`${e}¥n¥nFlush Failed. \n失敗しました。`);
			setTimeout(() => {
				location = '/';
			}, 10000)
		}

		function message(text) {
			msg.insertAdjacentHTML('beforeend', `<p>[${(new Date()).toString()}] ${text.replace(/¥n/g,'<br>')}</p>`)
		}
